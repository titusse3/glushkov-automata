\section{Résultat}

\subsection{La bibliothèque d'automate}

\subsection{L'application graphique}

\subsection{Phases de tests}

Pour ce projet, la phase de test, je l'ai mis en place à la fin de ce stage. En 
effet, cette partie n'avait été prévue d'être réalisé que s'il restait assez de 
temps pour ce faire. Les réunions hebdomadaires servaient entre autre à jouer en 
partie ce rôle. De plus à chaque ajout de fonctionnalités, j'essayai d'effectuer 
certain teste. Malgré cela, j'ai pu trouver le temps de mettre en place deux 
types de tests. Nous commencerons par voir la façon dont j'ai mis en place une 
des tests par propriétés. Puis nous verrons les testes de performances mises en 
place entre les deux implémentations d'automate.

\subsubsection{Test par propriétés}

% explication de comment fonctionne les testes propriétés
Les tests par propriétés, \textit{`property testing'} en anglais. Est une 
méthode de tests logicielle qui visent à tester les propriétés d'un résultat et 
non pas à comparer le résultat obtenu avec celui espérer~\cite{propertyTesting}. 
De plus, cette méthode ne nécessite pas d'avoir une autre implémentation pour 
comparer les résultats ou même de calculer à la main les résultats des 
opérations que l'on veut tester (Cette méthode est celle communément utilisé, 
des \textit{tests unitaires}). 

\vphantom{}

Outre cela, cette méthode de test convient extrêmement bien à la production 
d'objet mathématique. Notamment en ce qui concerne les automates, ils existent 
de nombreuses propriétés connues qui permet de facilité ces testées. Plus 
précisément, on peut par exemple pour les \textit{automates de Glushkov} se 
référer à l'article \textit{Characterization of Glushkov Automata} de Pascal 
Caron et Djelloul Ziadi~\cite{CaronZiadi2001}. Bien évidemment, cette méthode ne
montre pas que le programme fait exactement ce qu'il doit faire. Il faudrait 
pour cela effectue des preuves formelles mathématiques, tel que celle vue en 
cours d'algorithmique lors de cette licence (par le biais de la logique de 
\textit{Hoare} par exemple). Seulement ces preuves se révélant très longue à 
écrire, les tests par propriétés suffisent donc.  

\vphantom{}

% La façon dont ces mis en place en haskell
En \textit{Haskell}, c'est la bibliothèque \textit{QuickCheck} qui permet de 
mettre en place ce type de test. Une fois des propriétés définie, une génération 
aléatoire de cas de test sera effectuer, et ça sera sur ces cas que les 
propriétés se verrons testé. Pour générer ces cas de test aléatoire, il faut 
que les objets en question dérive la classe \mintinline{haskell}{Arbitrary} du 
module. Le terme `dérivé' en signifie ici que notre classe doit implémenter la 
méthode \mintinline{haskell}{arbitrary :: Gen a} avec \mintinline{haskell}{a}, 
le type que l'on veut tester. C'est grâce à cette fonction 
\mintinline{haskell}{arbitrary} que seront généré de façon aléatoire les objets 
sur lequel seront testé les propriétés. Enfin, pour tester ces propriétés, il 
faut appeler la fonction \mintinline{haskell}{quickCheck} qui prendra en 
paramètre une fonction qui doit avoir ce type 
\mintinline{haskell}{prop :: Arbitrary a => a -> Bool}. Cette fonction 
effectuera une génération de 100 objets et testera la fonction 
\mintinline{haskell}{prop} sur ces objets.

\vphantom{}

% la façon dont j'ai tester les propriétés et le réulstat de celui-ci
En ce qui concerne la mise en place des tests des deux implémentations de la 
bibliothèque d'automates, la première étape a été l'implémentation de la méthode 
\mintinline{haskell}{arbitrary} pour les types d'automates de la bibliothèque. 
Pour ce faire, la création d'un automate se fait par la génération d'une liste 
d'état et d'une liste de transition par le biais du module \textit{QuickCheck}. 
Ce ne sont pas les types \mintinline{haskell}{NFAG} et 
\mintinline{haskell}{NFAF}, qui implémente cette méthode, mais des types 
enveloppes. Cela est dû à la seule utilité de ce type pour ces tests. Une 
convention du langage n'autorise pas l'implémentation d'une classe par un type 
or de son fichier d'implémentation. Et il n'y a aucun intérêt à ce que ces deux 
types implémente \mintinline{haskell}{arbitrary} or des tests. Finalement les 
propriétés testées sont celle de la table~\ref{tab:proprietes}.

\begin{table}[H]
  \centering
  \begin{tabular}{ll}
  \toprule
  \textbf{Propriété} & \textbf{Description} \\
  \midrule
  \mintinline{haskell}{propAddState} & Vérifie que l'ajout d'un état.\\
  \mintinline{haskell}{propAddTransition} & Vérifie l'ajout d'une transition.\\
  \mintinline{haskell}{propRemoveState} & Vérifie la suppression d'un état.\\
  \mintinline{haskell}{propRemoveTransition} & Vérifie la suppression d'une transition.\\
  \mintinline{haskell}{propDirectSucc} & Vérifie les successeurs directs d'un état.\\
  \mintinline{haskell}{propDirectPred} & Vérifie les prédécesseurs directs d'un état.\\
  \mintinline{haskell}{propStandard} & Vérifie les propriétés d'un automate standard.\\
  \bottomrule
  \end{tabular}
  \caption{Résumé des propriétés testées sur les automates.}\label{tab:proprietes}
  \end{table}

\vphantom{}

Enfin, les testes sur la partie de transformation d'expression régulière en 
automate de \textit{Glushkov} se fais sur l'implémentation 
\mintinline{haskell}{NFAG} (Se référé à la section suivante pour les raisons de 
ce choix.). Comme pour la partie précédente, il faillait tout d'abord générer 
des expressions de manière aléatoires. Pour ce faire, j'ai utilisé le `parser' 
développé, permettant à partir d'une chaine de caractère d'obtenir l'expression
correspondante. Il m'a donc fallu créer une chaîne représentant une expression, 
et cela, de manière aléatoire. J'ai alors utilisé les fonctionnalités du module 
\textit{QuickCheck} pour cela. Après la génération de ces expressions régulière,
une conversion vers un automate s'effectuer à l'aide de l'algorithmique de 
\textit{Glushkov}. C'est cette convention qui se voit être testé par les 
propriétés définies dans l'article~\cite{CaronZiadi2001}. Avec notamment la 
définition d'orbite et d'orbite maximale et des propriétés qu'ils doivent 
respecter dans le cas d'un automate de \textit{Glushkov} (Ces propriétés sont 
les suivants, un automate de \textit{Glushkov} doit être \textbf{standard}, 
toutes les orbites maximales de cette automate doivent être 
\textbf{fortement stable} et \textbf{hautement transverse}).

\vphantom{}

On obtient alors les résultats de la figure~\ref{fig:resTest} lors d'un appelle 
à ces tests. Ce qui certifie la validité des implémentations faites.

\begin{figure}[H]
  \begin{minted}[frame=lines, fontsize=\small]{bash}
    $ stack test
    Testing NG.NFAG implementation...
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    Testing NF.NFAF implementation...
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    +++ OK, passed 100 tests.
    
    Testing Gluskov properties...
    +++ OK, passed 100 tests.
    
  \end{minted}
  \caption{Résultat des tests de propriétés des implémentations d'automates.}
  \label{fig:resTest}
\end{figure}

\subsubsection{Benchmark des implémentations d'automates}

% Comment fonctionne les benchmarks en haskell
Pour évaluer les performances des deux implémentations d'automates 
\mintinline{haskell}{NFAG} et \mintinline{haskell}{NFAF}, l'utilisation du 
module \textit{Criterion} a été faite. Pour rappels, la principale différence 
entre ces deux implémentations et que \mintinline{haskell}{NFAG}, utilise un 
graphe du module \textit{fgl} tandis que \mintinline{haskell}{NFAF} utilise une
fonction.

\vphantom{}

% les résultats obtenu sur les temps

% peut être plus tard parler des perfs en mémoires...

\subsection{Les possibilités d'amélioration}
